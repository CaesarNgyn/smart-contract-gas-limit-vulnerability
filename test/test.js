//expect: This is the assertion library from Chai, used to make assertions in the tests.
// ethers: This is the ethers.js library provided by Hardhat for interacting with Ethereum.
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Dos", () => {
  let deployer, attacker, user, auction;

  //This function runs before each test case to set up the test environment.
  beforeEach(async function () {

    /* This gets the list of signers (accounts) from the Hardhat environment.
deployer: The account that will deploy the contract.
attacker and user: Additional accounts for interacting with the contract.*/

    [deployer, attacker, user] = await ethers.getSigners();

    //gets the contract factory for the Auction contract using the deployer account.
    const Auction = await ethers.getContractFactory("Auction", deployer);

    //deploys the Auction contract with an initial owner address.
    // auction = await Auction.deploy("0x5Bc3e4b617  1eC06a8656603aD81A59D6cc752949"); // Replace ownerAddress with the actual address
    auction = await Auction.deploy();

    await auction.deployed();

    //place initial bids
    await auction.bid({ value: ethers.utils.parseEther("0.1") }); // Ensure the bid is made correctly

  });

  describe("Auction", () => {
    describe.skip("if bid is lower than highestBid", () => {
      it("Should NOT accept bids lower than current", async () => {
        await expect(auction.connect(user).bid({ value: ethers.utils.parseEther("0.05") })).to.be.revertedWith("Bid not high enough");
      });
    });
    describe.skip('if bid is higher than highest bid', () => {
      it("Should accept it and update highestBid", async () => {
        await auction.connect(user).bid({ value: ethers.utils.parseEther("0.15") });
        expect(await auction.highestBid()).to.eq(ethers.utils.parseEther("0.15"));
      });
      it("Should make msg.sender currentLeader", async () => {
        await auction.connect(user).bid({ value: ethers.utils.parseEther("0.15") });
        expect(await auction.currentLeader()).to.eq(user.address);
      });
      it("Should add previous leader and highestBid to refunds", async () => {
        //This test case ensures that when a new bid surpasses the current highest bid, the previous leader (initially deployer signer with a bid of 0.1 Ether) and their bid amount should be added to the refunds array in the auction contract.
        await auction.connect(user).bid({ value: ethers.utils.parseEther("0.15") });
        const [addr, amount] = await auction.refunds(0);
        expect(addr).to.eq(deployer.address);
        expect(amount).to.eq(ethers.utils.parseEther("0.1"));
      });
    });
    describe('when calling refundAll()', () => {
      it.skip("Should refund the bidders that didn't win", async () => {
        await auction.connect(user).bid({ value: ethers.utils.parseEther("0.15") });
        await auction.connect(deployer).bid({ value: ethers.utils.parseEther("0.2") });

        const userBalanceBefore = await ethers.provider.getBalance(user.address);
        console.log(">>userBalanceBefore ", userBalanceBefore)
        await auction.refundAll();
        const userBalanceAfter = await ethers.provider.getBalance(user.address);
        console.log(">>userBalanceAfter ", userBalanceAfter)

        console.log(">>difference", userBalanceAfter - userBalanceBefore)

        expect(userBalanceAfter).to.be.closeTo(userBalanceBefore.add(ethers.utils.parseEther("0.15")), ethers.utils.parseEther("0.01"));
      });
      it("Should revert if the amount of computation hits the block gas limit", async () => {
        // Loop to execute 1500 bids, increasing the bid amount incrementally
        for (let i = 0; i < 1500; i++) {
          await auction.connect(attacker).bid({
            value: ethers.utils.parseEther((0.15 + i * 0.01).toString())
          });
        }

        // Attempt to execute refundAll, which should hit the gas limit
        await expect(auction.refundAll()).to.be.revertedWith("out of gas");
      });
    });
  });
});
